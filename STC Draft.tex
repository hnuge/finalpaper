\documentclass[11pt,reqno]{amsart}

\setlength{\textheight}{8.8in}
\setlength{\topmargin}{-.1in}
%\setlength{\textwidth}{6in}
%\setlength{\oddsidemargin}{.26in}
%\setlength{\evensidemargin}{.26in}
\parskip=.08in

\usepackage[pagebackref]{hyperref} % for pdflatex
%\usepackage[hypertex,pagebackref]{hyperref} % for latex
\usepackage{xcolor}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[mathscr]{eucal}
\usepackage{MnSymbol}
\usepackage[frame,ps,matrix,arrow,curve,rotate,all,2cell,tips]{xy}
\usepackage{enumerate}


\setcounter{tocdepth}{1}

% The second argument here is about how to label the theorems, e.g. Theorem 2.2 is the second thing in section 2. The first thing in section 2 is subsection 2.1.
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{sublemma}[subsection]{Sub-Lemma}
\newtheorem{proposition}[subsection]{Proposition}
\newtheorem{corollary}[subsection]{Corollary}
\newtheorem{thm}[subsection]{Theorem}
\newtheorem{prop}[subsection]{Proposition}



%%% The following environments have roman body.

\theoremstyle{definition}
\newtheorem{definition}[subsection]{Definition}
\newtheorem{example}[subsection]{Example}
\newtheorem{remark}[subsection]{Remark}
\newtheorem{assumption}[subsection]{Assumption}
\newtheorem{convention}[subsection]{Convention}
\newtheorem{notation}[subsection]{Notation}
\newtheorem{conjecture}[subsection]{Conjecture}
\newtheorem{construction}[subsection]{Construction}
\newtheorem{work}[subsection]{Just For Us}

\numberwithin{equation}{subsection}

%\newtheorem{defn}[subsubsection]{Definition}
% donald has this command reserved
\newtheorem{conj}[subsection]{Conjecture}
\newtheorem{fact}[subsection]{Fact}
\newtheorem{problem}[subsection]{Problem}

% Common number systems
\renewcommand{\P}{\mathbb{P}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\bbP}{\mathbb{P}}
\renewcommand{\H}{\mathbb{H}}

\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}

\renewcommand{\O}{\mathsf{O}}
\newcommand{\bbA}{\mathbb{A}}
\newcommand{\bbC}{\mathbb{C}}
\newcommand{\bbG}{\mathbb{G}} % Additive/Multiplicative group
\newcommand{\G}{\mathbb{G}} % Additive/Multiplicative group

%\newcommand{\balpha}{\mathbb{\upalpha}}
%\newcommand{\bmu}{\mathbb{\upmu}}



















\begin{document}

\title{Self-Tuning Clustering: An Adaptive Clustering Method for Transaction Data}

\author{Haley Nugent, Taylor Heilman}


\maketitle

%===================
\section{Introduction}
%===================

Database mining has wide applications for improving marketing strategies. To improve these marketing strategies, we use data clustering. Data clustering divides a set of data items into separate groups such that items in the same group are as similar to one another as possible. Clustering large datasets can uncover useful patterns among the data. 

Market-basket data is known to have high dimensionality, sparsity, and to have massive outliers. The {\em small-large (SL) ratio} is the ratio of the number of small items to large items in the data. A {\em large item} is an item which occurs frequently in transactions. A {\em small item} is an item that occurs infrequently in transactions. Smaller SL ratios indicate more similarity between the items in the cluster. This paper develops a {\em Self-Tuning Clustering algorithm (algorithm STC)} to efficiently cluster the market-basket data by adaptively tuning the SL ratio. The algorithm consists of three phases:
	\begin{enumerate}
		\item {\em pre-determination}: calculates the {\em minimum support S} and the {\em maximum ceiling E} according to a given parameter called {\em SL distribution rate $\beta$}.
		
		\item {\em allocation}: Algorithm STC uses the minimum support S to identify the large items. It uses the maximum ceiling E to identify the small items. It accomplishes this by scanning the database and allocating each transaction to a cluster for minimizing the SL ratio.
		
		\item {\em refinement}: Each transaction is evaluated to minimize its SL ratio in its corresponding cluster. 
	\end{enumerate}
	
	The algorithm uses two different kinds of SL ratio thresholds to evaluate the quality of the clustering, {\em output SL ratio threshold $\alpha^o$} and {\em input Sl ratio threshold $\alpha^i$}. A transaction is moved from one cluster to the excess pool if its SL ratio is larger than $\alpha^o$ and moved from the excess pool to one cluster is the SL ratio is smaller than $\alpha^i$.
	
Algorithm STC significantly improves the clustering quality for synthetic and real market-basket data. 


%==================================
\section{Problem Description}
%==================================

The market-basket data is represented by a set of transactions $D = {t_1, t_2, ..., t_h}$, where $D$ is the database holding the set of transactions. Each transaction $t_i$ is a set of items ${i_1, i_2,...,i_h}$. A clustering $U =< C_1, C_2, ..., C_k>$ is a partition of transactions where $C_i$ is a cluster consisting of a set of transactions. The minimum support $S$ and the maximum ceiling $E$ are determined according to the SL distribution rate $\beta$ in the pre-determination phase. 

\subsection{Large Items and Small Items}


$Sup_C(i)$ is the support of an item $i$ in a cluster $C$. If $Sup_C(i)$ is larger than the minimum support $S$, the item $i$ in a cluster $C$ is  called a {\em large item}. If an item $j$ in a cluster $C$ has a $Sup_C(j)$ that is smaller than the maximum ceiling $E$ the item $j$ is called a {\em small item}. An item is called a middle item if it is neither large or small.

\subsection{Small-Large (SL) Ratio}

There are three kinds of SL ratios that need to be calculated in the data clustering procedure.
	\begin{enumerate}


	\item \textbf{SL Ratio of a Transaction:} The SL ratio for a transaction $t$ in cluster $C_i$ is defined as:
	$$R_{SL}(C_i, t) = \frac{|S(C_i,t)|}{|L(C_i, t)|} ,$$
$|S(C_i,t)|$ represents the number of small items in $t$ and $|L(C_i,t)|$ represents the number of large items in $t$.


	\item \textbf{SL Ratio of a Clustering:} The SL ratio for a clustering $U = <C_1, ..., C_p>$ is defined as:
	$$R_{SL}(U) = \sum_{i=1}^{p} \sum_{j=1}^{N^T(C_i)} R_{SL}(C_i, t_j), $$
	$N^T(C_i)$ is the number of transactions and $t_j$ is the $j$th transaction in the cluster $C_i$. 
	
	
	
	\item \textbf{Average SL Ratio:} The average SL ratio for a clustering $U =<C_1, ..., C_p>$ is defined as:
	$$\alpha(u) = \frac{R_{SL}(U)}{N^T(U)}$$
	$N^T(U)$ is the number of transactions in clustering $U$.
	
	\end{enumerate}

\subsection{The Objective of Clustering Market-Basket Data}

The objective clustering market basket data is {\em Given a database of transactions, determine a clustering U such that the average SL ratio $\alpha(U)$ is minimized.} The large items in each cluster are the products which are sold frequently. The clustering technique aims to maximize both the {\em intra-cluster similarity} and the {\em inter-cluster dissimilarity} of the data in order to minimize the average SL ratio. 

\textbf{Intra-Cluster Similarity:} Intra-cluster similarity of transactions is achieved by maximizing the number of large items in each cluster while minimizing the number of small items in each cluster. We know that an item $i$ is large if there are relatively many transactions containing $i$, while an item $j$ is small if there are relatively few transactions containing $j$. Transactions are similar to one another if the contain many common large items and fewer small items. 

\textbf{Inter-Cluster Dissimilarity:} We achieve inter-cluster dissimilarity of transactions by maximizing the number of large items and minimizing the number of small items so dissimilar transactions will be allocated to the different clusters. If an item $i$ is large in a cluster $C_a$, $i$ should be small in cluster $C_b$. 

%\begin{theorem}
%\end{theorem}

%\begin{remark}
%\end{remark}



%==================================
\section{Conclusion}
%==================================
Algorithm STC utilizes a self-tuning technique for adaptively tuning the input and output SL ratio thresholds to minimize the SL ratios of transactions in the clusters efficiently. 


\end{document}



